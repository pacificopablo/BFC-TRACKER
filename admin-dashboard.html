<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Baccarat Fund Admin Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
  </head>
  <body class="bg-gray-900 text-white min-h-screen p-4">
    <!-- Header -->
    <header class="flex justify-between items-center mb-8">
      <h1 class="text-2xl font-bold flex items-center">
        <span class="mr-2">üëë</span> Baccarat Fund Admin
      </h1>
      <div class="flex space-x-2">
        <button id="serverTimeBtn" class="bg-blue-600 px-4 py-2 rounded hover:bg-blue-700 text-sm">
          Server Time
        </button>
        <button id="adjustBalanceBtn" class="bg-purple-600 px-4 py-2 rounded hover:bg-purple-700 text-sm">
          Adjust Balances
        </button>
        <button id="logoutBtn" class="bg-red-600 px-4 py-2 rounded hover:bg-red-700 text-sm">
          Logout
        </button>
      </div>
    </header>

    <!-- Summary Cards -->
    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-8">
      <div class="bg-gray-800 p-4 rounded-lg shadow">
        <p class="text-sm text-gray-400">Total Members</p>
        <p class="text-2xl font-bold" id="totalMembers">0</p>
      </div>
      <div class="bg-gray-800 p-4 rounded-lg shadow">
        <p class="text-sm text-gray-400">Total Shares</p>
        <p class="text-2xl font-bold" id="totalShares">0</p>
      </div>
      <div class="bg-gray-800 p-4 rounded-lg shadow">
        <p class="text-sm text-gray-400">Total Balance</p>
        <p class="text-2xl font-bold">‚Ç±<span id="totalBalance">0.00</span></p>
      </div>
    </div>

    <!-- Fund Growth Chart -->
    <div class="bg-gray-800 p-4 rounded-lg shadow mb-8">
      <h2 class="text-lg font-bold mb-4">üìä Fund Growth</h2>
      <canvas id="fundChart" height="100"></canvas>
    </div>

    <!-- Distribute Profit/Loss -->
    <div class="bg-gray-800 p-4 rounded-lg shadow mb-8">
      <h2 class="text-lg font-bold mb-4">üí∏ Distribute Profit/Loss</h2>
      <p class="text-sm mb-4">Fund Balance: ‚Ç±<span id="fundBalance">0.00</span></p>
      <form id="profitForm" class="space-y-4">
        <div>
          <label class="block text-sm mb-1">Transaction Type</label>
          <select id="transactionType" class="w-full p-2 bg-gray-700 rounded text-white">
            <option value="profit">Profit</option>
            <option value="loss">Loss</option>
          </select>
        </div>
        <div>
          <label class="block text-sm mb-1">Amount (‚Ç±)</label>
          <input
            type="number"
            id="profitAmount"
            class="w-full p-2 bg-gray-700 rounded text-white"
            placeholder="Enter amount"
            min="0"
            step="0.01"
            required
          />
        </div>
        <button
          type="submit"
          id="distributeBtn"
          class="w-full bg-green-600 px-4 py-2 rounded hover:bg-green-700 disabled:bg-gray-600"
        >
          Distribute
        </button>
      </form>
      <p id="profitError" class="text-red-500 text-sm mt-2 hidden"></p>
    </div>

    <!-- Members Section -->
    <div class="mb-8">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-lg font-bold">üë• Members</h2>
        <input
          type="text"
          id="searchInput"
          placeholder="Search members..."
          class="p-2 bg-gray-700 rounded text-white w-64"
        />
      </div>
      <div id="membersList" class="grid sm:grid-cols-2 lg:grid-cols-3 gap-4"></div>
    </div>

    <!-- Top Shareholders -->
    <div class="bg-gray-800 p-4 rounded-lg shadow mb-8">
      <h2 class="text-lg font-bold mb-4">üèÜ Top 5 Shareholders</h2>
      <ul id="topShareholders" class="list-disc list-inside text-sm"></ul>
    </div>

    <!-- Transaction Requests -->
    <div class="bg-gray-800 p-4 rounded-lg shadow mb-8">
      <h2 class="text-lg font-bold mb-4">üí∞ Transaction Requests</h2>
      <div id="requestsList" class="space-y-4 max-h-80 overflow-y-auto"></div>
    </div>

    <!-- Daily Distribution Report -->
    <div class="bg-gray-800 p-4 rounded-lg shadow mb-8">
      <h2 class="text-lg font-bold mb-4">üìà Daily Distribution Report</h2>
      <div id="dailyReportList" class="space-y-4 max-h-80 overflow-y-auto"></div>
    </div>

    <!-- Transaction History -->
    <div class="bg-gray-800 p-4 rounded-lg shadow">
      <h2 class="text-lg font-bold mb-4">üìú Transaction History</h2>
      <div class="flex flex-col sm:flex-row justify-between mb-4 space-y-2 sm:space-y-0 sm:space-x-2">
        <select id="historyFilter" class="p-2 bg-gray-700 rounded text-white">
          <option value="all">All</option>
          <option value="deposit">Deposits</option>
          <option value="cashout">Cash Outs</option>
          <option value="profit">Profits</option>
          <option value="loss">Losses</option>
        </select>
        <select id="historySort" class="p-2 bg-gray-700 rounded text-white">
          <option value="desc">Newest First</option>
          <option value="asc">Oldest First</option>
        </select>
      </div>
      <div id="historyList" class="space-y-4 max-h-80 overflow-y-auto"></div>
    </div>

    <!-- Edit Member Modal -->
    <div id="editModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden flex items-center justify-center">
      <div class="bg-gray-800 p-6 rounded-lg w-full max-w-md">
        <h2 class="text-lg font-bold mb-4">Edit Member</h2>
        <form id="editForm" class="space-y-4">
          <input type="hidden" id="editMemberId" />
          <div>
            <label class="block text-sm">Name</label>
            <input type="text" id="editName" class="w-full p-2 bg-gray-700 rounded text-white" required />
          </div>
          <div>
            <label class="block text-sm">Email</label>
            <input type="email" id="editEmail" class="w-full p-2 bg-gray-700 rounded text-white" required />
          </div>
          <div>
            <label class="block text-sm">Status</label>
            <select id="editStatus" class="w-full p-2 bg-gray-700 rounded text-white">
              <option value="approved">Approved</option>
              <option value="pending">Pending</option>
              <option value="rejected">Rejected</option>
            </select>
          </div>
          <div>
            <label class="block text-sm">Shares</label>
            <input type="number" id="editShares" class="w-full p-2 bg-gray-700 rounded text-white" min="0" required />
          </div>
          <div>
            <label class="block text-sm">Balance</label>
            <input
              type="number"
              id="editBalance"
              class="w-full p-2 bg-gray-700 rounded text-white"
              min="0"
              step="0.01"
              required
            />
          </div>
          <div>
            <label class="block text-sm">Approval Date</label>
            <input
              type="datetime-local"
              id="editApprovalDate"
              class="w-full p-2 bg-gray-700 rounded text-white"
              required
            />
          </div>
          <div class="flex justify-end space-x-2">
            <button type="button" id="cancelEdit" class="bg-gray-600 px-4 py-2 rounded">Cancel</button>
            <button type="submit" class="bg-blue-600 px-4 py-2 rounded">Save</button>
          </div>
        </form>
      </div>
    </div>

    <script type="module">
      // Firebase Imports
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
      import {
        getFirestore,
        collection,
        getDocs,
        getDoc,
        doc,
        updateDoc,
        deleteDoc,
        query,
        orderBy,
        onSnapshot,
        writeBatch,
        setDoc,
        serverTimestamp,
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
      import { getAuth, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

      // Firebase Config
      const firebaseConfig = {
        apiKey: "AIzaSyCN0dBQXoaWh_13lF0ON25otUpeH3OGINQ",
        authDomain: "bfc-tracker.firebaseapp.com",
        projectId: "bfc-tracker",
        storageBucket: "bfc-tracker.firebasestorage.app",
        messagingSenderId: "127052459580",
        appId: "1:127052459580:web:c3d5caa9302238c11cdd39",
        measurementId: "G-PNYRCFJHYM",
      };

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);
      const auth = getAuth(app);

      // DOM Elements
      const elements = {
        totalMembers: document.getElementById("totalMembers"),
        totalShares: document.getElementById("totalShares"),
        totalBalance: document.getElementById("totalBalance"),
        fundBalance: document.getElementById("fundBalance"),
        membersList: document.getElementById("membersList"),
        topShareholders: document.getElementById("topShareholders"),
        requestsList: document.getElementById("requestsList"),
        historyList: document.getElementById("historyList"),
        dailyReportList: document.getElementById("dailyReportList"),
        searchInput: document.getElementById("searchInput"),
        historyFilter: document.getElementById("historyFilter"),
        historySort: document.getElementById("historySort"),
        profitForm: document.getElementById("profitForm"),
        profitAmount: document.getElementById("profitAmount"),
        distributeBtn: document.getElementById("distributeBtn"),
        profitError: document.getElementById("profitError"),
        transactionType: document.getElementById("transactionType"),
        editModal: document.getElementById("editModal"),
        editForm: document.getElementById("editForm"),
        editMemberId: document.getElementById("editMemberId"),
        editName: document.getElementById("editName"),
        editEmail: document.getElementById("editEmail"),
        editStatus: document.getElementById("editStatus"),
        editShares: document.getElementById("editShares"),
        editBalance: document.getElementById("editBalance"),
        editApprovalDate: document.getElementById("editApprovalDate"),
        cancelEdit: document.getElementById("cancelEdit"),
        logoutBtn: document.getElementById("logoutBtn"),
        serverTimeBtn: document.getElementById("serverTimeBtn"),
        adjustBalanceBtn: document.getElementById("adjustBalanceBtn"),
      };

      let allMembers = [];
      let allTransactions = [];
      let fundChartInstance = null;
      const SUBMISSION_COOLDOWN = 5000;
      const HOURS_THRESHOLD = 24;
      let lastSubmissionTime = 0;

      // Utility Functions
      const formatCurrency = (value) =>
        parseFloat(value || 0).toLocaleString("en-PH", { minimumFractionDigits: 2 });

      const showError = (message) => {
        elements.profitError.textContent = message;
        elements.profitError.classList.remove("hidden");
        setTimeout(() => elements.profitError.classList.add("hidden"), 5000);
      };

      const showLoading = (element, message = "Loading...") => {
        element.innerHTML = `<p class="text-gray-400">${message}</p>`;
      };

      // Get Server Time
      async function getServerTime() {
        const tempRef = doc(collection(db, "temp"));
        await setDoc(tempRef, { timestamp: serverTimestamp() });
        const docSnap = await getDoc(tempRef);
        const serverTime = docSnap.exists() ? docSnap.data().timestamp.toDate() : new Date();
        await deleteDoc(tempRef);
        return serverTime;
      }

      // Get PHT Day Range
      function getPHTDayRange(serverTime) {
        const phtTime = new Date(serverTime.getTime() + 8 * 60 * 60 * 1000);
        const startOfDay = new Date(phtTime).setHours(0, 0, 0, 0);
        const endOfDay = new Date(phtTime).setHours(23, 59, 59, 999);
        return {
          start: new Date(startOfDay - 8 * 60 * 60 * 1000),
          end: new Date(endOfDay - 8 * 60 * 60 * 1000),
        };
      }

      // Check Member Eligibility (for profits only)
      async function isMemberEligible(member, serverTime) {
        if (member.status !== "approved") return { eligible: false, reason: "Not Approved" };
        if (member.balance <= 0) return { eligible: false, reason: "Zero/Negative Balance" };

        const approvalDate = member.approvalDate?.toDate
          ? member.approvalDate.toDate()
          : new Date(member.approvalDate);
        if (!approvalDate || isNaN(approvalDate)) return { eligible: false, reason: "No Approval Date" };

        const hoursSinceApproval = (serverTime - approvalDate) / (1000 * 60 * 60);
        if (hoursSinceApproval < HOURS_THRESHOLD) {
          return { eligible: false, reason: `New Member (${hoursSinceApproval.toFixed(2)} hrs)` };
        }

        const lastDistribution = member.lastDistribution?.toDate
          ? member.lastDistribution.toDate()
          : member.lastDistribution
            ? new Date(member.lastDistribution)
            : null;
        if (lastDistribution && lastDistribution >= getPHTDayRange(serverTime).start) {
          return { eligible: false, reason: "Already Received Today" };
        }

        return { eligible: true, reason: "Eligible" };
      }

      // Adjust Balances (1 share = ‚Ç±10)
      async function adjustBalances() {
        try {
          const batch = writeBatch(db);
          const serverTime = await getServerTime();

          for (const member of allMembers) {
            const eligibility = await isMemberEligible(member, serverTime);
            if (!eligibility.eligible) continue; // Skip ineligible members

            const newBalance = (member.shares || 0) * 10; // 1 share = ‚Ç±10
            batch.update(doc(db, "users", member.id), { balance: newBalance });
          }

          await batch.commit();
          console.log("Balances adjusted successfully: 1 share = ‚Ç±10");
        } catch (error) {
          showError("Failed to adjust balances: " + error.message);
        }
      }

      // Load Fund Balance
      async function loadFundBalance() {
        const fundSnapshot = await getDocs(collection(db, "fund"));
        let balance = 0;

        // Calculate total balance from members
        const snapshot = await getDocs(collection(db, "users"));
        allMembers = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
        balance = allMembers.reduce((sum, m) => sum + (m.balance || 0), 0);

        // Include any undistributed profit/loss from profit_distributions
        const profitSnapshot = await getDocs(collection(db, "profit_distributions"));
        profitSnapshot.docs.forEach((doc) => {
          const data = doc.data();
          if (data.excessAmount) {
            balance += data.type === "profit" ? data.excessAmount : -data.excessAmount;
          }
        });

        if (fundSnapshot.empty) {
          await setDoc(doc(db, "fund", "main"), { balance });
        } else {
          await updateDoc(doc(db, "fund", fundSnapshot.docs[0].id), { balance });
        }

        elements.fundBalance.textContent = formatCurrency(balance);
        return balance;
      }

      // Initialize Chart
      function initializeChart() {
        if (fundChartInstance) fundChartInstance.destroy();
        const ctx = document.getElementById("fundChart").getContext("2d");
        fundChartInstance = new Chart(ctx, {
          type: "line",
          data: {
            labels: [],
            datasets: [
              {
                label: "Fund Balance",
                data: [],
                backgroundColor: "rgba(59, 130, 246, 0.2)",
                borderColor: "rgba(59, 130, 246, 1)",
                borderWidth: 2,
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            plugins: { legend: { labels: { color: "white" } } },
            scales: {
              x: { ticks: { color: "white" } },
              y: { ticks: { color: "white", callback: (value) => `‚Ç±${formatCurrency(value)}` }, beginAtZero: true },
            },
          },
        });
      }

      // Update Chart
      async function updateChart() {
        const q = query(collection(db, "profit_distributions"), orderBy("timestamp", "asc"));
        const snapshot = await getDocs(q);
        const labels = [];
        const data = [];
        let balance = (await loadFundBalance()) || 0;

        snapshot.docs.forEach((doc) => {
          const d = doc.data();
          const date = d.timestamp.toDate().toLocaleDateString("en-PH", { month: "short", day: "numeric" });
          if (!labels.includes(date)) {
            labels.push(date);
            balance += d.type === "profit" ? (d.amount + (d.excessAmount || 0)) : -(d.amount + (d.excessAmount || 0));
            data.push(balance);
          }
        });

        if (labels.length === 0) {
          const now = new Date();
          labels.push(now.toLocaleDateString("en-PH", { month: "short", day: "numeric" }));
          data.push(balance);
        }

        fundChartInstance.data.labels = labels;
        fundChartInstance.data.datasets[0].data = data;
        fundChartInstance.update();
      }

      // Load Members
      async function loadMembers() {
        showLoading(elements.membersList);
        showLoading(elements.topShareholders);
        const snapshot = await getDocs(collection(db, "users"));
        allMembers = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));

        // Adjust balances before rendering
        await adjustBalances();

        let memberCount = 0,
            shareTotal = 0,
            balanceTotal = 0;
        elements.membersList.innerHTML = "";
        const serverTime = await getServerTime();

        for (const m of allMembers) {
          memberCount++;
          shareTotal += m.shares || 0;
          balanceTotal += m.balance || 0;

          const eligibility = await isMemberEligible(m, serverTime);
          const div = document.createElement("div");
          div.className = "bg-gray-800 p-4 rounded-lg shadow";
          div.innerHTML = `
            <p><strong>Name:</strong> ${m.name || "N/A"}</p>
            <p><strong>Email:</strong> ${m.email || "N/A"}</p>
            <p><strong>Status:</strong> <span class="px-2 py-1 rounded ${
              m.status === "approved"
                ? "bg-green-600"
                : m.status === "pending"
                  ? "bg-yellow-600"
                  : "bg-red-600"
            }">${m.status || "N/A"}</span></p>
            <p><strong>Shares:</strong> ${m.shares || 0}</p>
            <p><strong>Balance:</strong> ‚Ç±${formatCurrency(m.balance)}</p>
            <p><strong>Eligible:</strong> ${eligibility.eligible ? "Yes" : `No (${eligibility.reason})`}</p>
            <div class="flex space-x-2 mt-2">
              <button data-id="${m.id}" class="edit-btn bg-blue-600 px-3 py-1 rounded text-sm hover:bg-blue-700">Edit</button>
              <button data-id="${m.id}" data-name="${
                m.name || "Unknown"
              }" class="delete-btn bg-red-600 px-3 py-1 rounded text-sm hover:bg-red-700">Delete</button>
            </div>
          `;
          elements.membersList.appendChild(div);
        }

        elements.totalMembers.textContent = memberCount;
        elements.totalShares.textContent = shareTotal;
        elements.totalBalance.textContent = formatCurrency(balanceTotal);
        updateTopShareholders(serverTime);
      }

      // Update Top Shareholders
      async function updateTopShareholders(serverTime) {
        const top = allMembers
          .filter(async (m) => m.status === "approved" && (await isMemberEligible(m, serverTime)).eligible)
          .sort((a, b) => (b.shares || 0) - (a.shares || 0))
          .slice(0, 5);

        elements.topShareholders.innerHTML = top.length
          ? top.map((m) => `<li>${m.name || "N/A"} ‚Äî ${m.shares || 0} shares</li>`).join("")
          : '<p class="text-gray-400">No eligible shareholders.</p>';
      }

      // Search Members
      elements.searchInput.addEventListener("input", async () => {
        const query = elements.searchInput.value.toLowerCase();
        const filtered = allMembers.filter(
          (m) =>
            m.name?.toLowerCase().includes(query) ||
            m.email?.toLowerCase().includes(query) ||
            m.status?.toLowerCase().includes(query)
        );
        elements.membersList.innerHTML = "";
        const serverTime = await getServerTime();

        for (const m of filtered) {
          const eligibility = await isMemberEligible(m, serverTime);
          const div = document.createElement("div");
          div.className = "bg-gray-800 p-4 rounded-lg shadow";
          div.innerHTML = `
            <p><strong>Name:</strong> ${m.name || "N/A"}</p>
            <p><strong>Email:</strong> ${m.email || "N/A"}</p>
            <p><strong>Status:</strong> <span class="px-2 py-1 rounded ${
              m.status === "approved"
                ? "bg-green-600"
                : m.status === "pending"
                  ? "bg-yellow-600"
                  : "bg-red-600"
            }">${m.status}</span></p>
            <p><strong>Shares:</strong> ${m.shares || 0}</p>
            <p><strong>Balance:</strong> ‚Ç±${formatCurrency(m.balance)}</p>
            <p><strong>Eligible:</strong> ${eligibility.eligible ? "Yes" : `No (${eligibility.reason})`}</p>
            <div class="flex space-x-2 mt-2">
              <button data-id="${m.id}" class="edit-btn bg-blue-600 px-3 py-1 rounded text-sm hover:bg-blue-700">Edit</button>
              <button data-id="${m.id}" data-name="${
                m.name || "Unknown"
              }" class="delete-btn bg-red-600 px-3 py-1 rounded text-sm hover:bg-red-700">Delete</button>
            </div>
          `;
          elements.membersList.appendChild(div);
        }
      });

      // Load Transaction Requests
      function loadRequests() {
        showLoading(elements.requestsList);
        const q = query(collection(db, "transactions"), orderBy("timestamp", "desc"));
        onSnapshot(q, (snapshot) => {
          const pending = snapshot.docs.filter((doc) => doc.data().status === "pending");
          elements.requestsList.innerHTML = pending.length
            ? pending
                .map(
                  (doc) => `
            <div class="bg-gray-700 p-4 rounded-lg">
              <p><strong>Member:</strong> ${doc.data().memberName || "N/A"}</p>
              <p><strong>Type:</strong> ${doc.data().type || "N/A"}</p>
              <p><strong>Amount:</strong> ‚Ç±${formatCurrency(doc.data().amount)}</p>
              <p><strong>Date:</strong> ${doc.data().timestamp?.toDate().toLocaleString("en-PH") || "N/A"}</p>
              <div class="flex space-x-2 mt-2">
                <button data-id="${doc.id}" class="approve-btn bg-green-600 px-3 py-1 rounded text-sm hover:bg-green-700">Approve</button>
                <button data-id="${doc.id}" class="reject-btn bg-red-600 px-3 py-1 rounded text-sm hover:bg-red-700">Reject</button>
              </div>
            </div>
          `
                )
                .join("")
            : '<p class="text-gray-400">No pending requests.</p>';
        });
      }

      // Load Transaction History
      function loadTransactionHistory() {
        showLoading(elements.historyList);
        const profitQ = query(collection(db, "profit_distributions"), orderBy("timestamp", "desc"));
        const transactionQ = query(collection(db, "transactions"), orderBy("timestamp", "desc"));

        onSnapshot(profitQ, (profitSnap) => {
          onSnapshot(transactionQ, (txnSnap) => {
            allTransactions = [
              ...profitSnap.docs.map((doc) => ({
                id: doc.id,
                type: doc.data().type === "profit" ? "Profit Distribution" : "Loss Deduction",
                filterType: doc.data().type,
                amount: doc.data().amount,
                excessAmount: doc.data().excessAmount || 0,
                timestamp: doc.data().timestamp?.toDate() || new Date(),
                details: `To ${doc.data().eligibleMemberCount} of ${doc.data().totalMemberCount} members`,
              })),
              ...txnSnap.docs.map((doc) => ({
                id: doc.id,
                type: doc.data().type === "deposit" ? "Deposit" : "Cash Out",
                filterType: doc.data().type,
                amount: doc.data().amount,
                timestamp: doc.data().timestamp?.toDate() || new Date(),
                details: `Member: ${doc.data().memberName || "N/A"}, Status: ${doc.data().status}`,
              })),
            ];
            displayTransactionHistory();
          });
        });
      }

      // Display Transaction History
      function displayTransactionHistory() {
        const filter = elements.historyFilter.value;
        const sort = elements.historySort.value;
        let filtered = filter === "all" ? allTransactions : allTransactions.filter((t) => t.filterType === filter);
        filtered.sort((a, b) => (sort === "desc" ? b.timestamp - a.timestamp : a.timestamp - b.timestamp));

        elements.historyList.innerHTML = filtered.length
          ? filtered
              .map(
                (t) => `
            <div class="bg-gray-700 p-4 rounded-lg">
              <p><strong>Type:</strong> ${t.type}</p>
              <p><strong>Amount:</strong> ‚Ç±${formatCurrency(t.amount)}</p>
              ${t.excessAmount ? `<p><strong>Excess:</strong> ‚Ç±${formatCurrency(t.excessAmount)}</p>` : ""}
              <p><strong>Date:</strong> ${t.timestamp.toLocaleString("en-PH")}</p>
              <p><strong>Details:</strong> ${t.details}</p>
            </div>
          `
              )
              .join("")
          : '<p class="text-gray-400">No transactions found.</p>';
      }

      // Load Daily Report
      async function loadDailyReport() {
        showLoading(elements.dailyReportList);
        const serverTime = await getServerTime();
        const { start, end } = getPHTDayRange(serverTime);
        const q = query(collection(db, "member_distributions"), orderBy("timestamp", "desc"));
        const snapshot = await getDocs(q);
        const todayDist = snapshot.docs.filter(
          (doc) => doc.data().timestamp?.toDate() >= start && doc.data().timestamp?.toDate() <= end
        );

        elements.dailyReportList.innerHTML = todayDist.length
          ? todayDist
              .map(
                (doc) => `
            <div class="bg-gray-700 p-4 rounded-lg">
              <p><strong>Member:</strong> ${doc.data().memberName || "N/A"}</p>
              <p><strong>Type:</strong> ${doc.data().type === "profit" ? "Profit" : "Loss"}</p>
              <p><strong>Amount:</strong> ${doc.data().type === "profit" ? "+" : "-"}‚Ç±${formatCurrency(
                  doc.data().amount
                )}</p>
              <p><strong>Date:</strong> ${doc.data().timestamp?.toDate().toLocaleString("en-PH") || "N/A"}</p>
            </div>
          `
              )
              .join("")
          : '<p class="text-gray-400">No distributions today.</p>';
      }

      // Distribute Profit/Loss
      elements.profitForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const now = Date.now();
        if (now - lastSubmissionTime < SUBMISSION_COOLDOWN) {
          showError(`Please wait ${Math.ceil((SUBMISSION_COOLDOWN - (now - lastSubmissionTime)) / 1000)} seconds.`);
          return;
        }
        lastSubmissionTime = now;
        elements.distributeBtn.disabled = true;

        try {
          const type = elements.transactionType.value;
          const totalAmount = parseFloat(elements.profitAmount.value);
          if (totalAmount <= 0) throw new Error("Amount must be greater than 0.");

          const fundSnap = await getDocs(collection(db, "fund"));
          const fundDoc = fundSnap.docs[0];
          const fundBalance = fundDoc.data().balance || 0;
          const serverTime = await getServerTime();
          const batch = writeBatch(db);
          let totalDistributed = 0;
          let eligibleMembers = [];
          let totalShares = 0;

          // Create distRef outside the if-else block
          const distRef = doc(collection(db, "profit_distributions"));

          if (type === "profit") {
            // Profit: Use isMemberEligible and 10% balance cap
            eligibleMembers = (
              await Promise.all(
                allMembers.map(async (m) => ((await isMemberEligible(m, serverTime)).eligible ? m : null))
              )
            ).filter((m) => m && m.shares > 0);
            totalShares = eligibleMembers.reduce((sum, m) => sum + (m.shares || 0), 0);

            if (!eligibleMembers.length) throw new Error("No eligible members with shares.");

            eligibleMembers.forEach((m) => {
              const memberBalance = (m.shares || 0) * 10; // 1 share = ‚Ç±10
              const memberDist = Math.min(memberBalance * 0.1, totalAmount - totalDistributed); // Cap at 10% of balance
              if (memberDist <= 0) return;

              const newBalance = m.balance + memberDist;
              totalDistributed += memberDist;

              batch.update(doc(db, "users", m.id), {
                balance: newBalance,
                lastDistribution: serverTimestamp(),
              });

              batch.set(doc(collection(db, "member_distributions")), {
                memberId: m.id,
                memberName: m.name,
                type: "profit",
                amount: memberDist,
                timestamp: serverTimestamp(),
                distributionId: distRef.id,
              });
            });
          } else {
            // Loss: Divide equally among members with status !== "pending" and shares > 0, no 10% cap
            eligibleMembers = allMembers.filter((m) => m.status !== "pending" && m.shares > 0);
            totalShares = eligibleMembers.reduce((sum, m) => sum + (m.shares || 0), 0);

            if (!eligibleMembers.length) throw new Error("No members with non-pending status and positive shares.");

            const lossPerMember = totalAmount / eligibleMembers.length; // Equal division

            eligibleMembers.forEach((m) => {
              const memberDist = Math.min(lossPerMember, m.balance); // Cap at balance to prevent negative
              if (memberDist <= 0) return;

              const newBalance = Math.max(0, m.balance - memberDist);
              totalDistributed += memberDist;

              batch.update(doc(db, "users", m.id), {
                balance: newBalance,
                lastDistribution: serverTimestamp(),
              });

              batch.set(doc(collection(db, "member_distributions")), {
                memberId: m.id,
                memberName: m.name,
                type: "loss",
                amount: memberDist,
                timestamp: serverTimestamp(),
                distributionId: distRef.id,
              });
            });
          }

          if (totalDistributed > totalAmount) throw new Error("Insufficient amount to distribute.");
          const excessAmount = totalAmount - totalDistributed;
          const newFundBalance = fundBalance + (type === "profit" ? totalDistributed + excessAmount : -(totalDistributed + excessAmount));
          if (newFundBalance < 0) throw new Error("Insufficient fund balance.");

          batch.update(doc(db, "fund", fundDoc.id), { balance: newFundBalance });

          batch.set(distRef, {
            type,
            amount: totalDistributed,
            excessAmount: excessAmount > 0 ? excessAmount : 0,
            timestamp: serverTimestamp(),
            adminId: auth.currentUser.uid,
            eligibleMemberCount: eligibleMembers.length,
            totalMemberCount: allMembers.length,
            totalShares,
          });

          await batch.commit();
          elements.profitForm.reset();
          // Note: adjustBalances may reset balances to shares * 10, undoing distributions unless shares are updated
          // await adjustBalances(); // Uncomment if you want to reset balances
          await loadMembers();
          await loadFundBalance();
          await loadDailyReport();
          await updateChart();
          alert(`Successfully ${type === "profit" ? "distributed profit" : "deducted loss"} of ‚Ç±${formatCurrency(totalDistributed)}! ${excessAmount > 0 ? `Excess ‚Ç±${formatCurrency(excessAmount)} added to fund balance.` : ""}`);
        } catch (error) {
          showError(error.message);
        } finally {
          elements.distributeBtn.disabled = false;
        }
      });

      // Edit Member
      elements.membersList.addEventListener("click", async (e) => {
        if (e.target.classList.contains("edit-btn")) {
          const id = e.target.dataset.id;
          const member = allMembers.find((m) => m.id === id);
          elements.editMemberId.value = id;
          elements.editName.value = member.name || "";
          elements.editEmail.value = member.email || "";
          elements.editStatus.value = member.status || "pending";
          elements.editShares.value = member.shares || 0;
          elements.editBalance.value = member.balance || 0;
          elements.editApprovalDate.value = member.approvalDate
            ? member.approvalDate.toDate().toISOString().slice(0, 16)
            : new Date().toISOString().slice(0, 16);
          elements.editModal.classList.remove("hidden");
        } else if (e.target.classList.contains("delete-btn")) {
          if (confirm(`Are you sure you want to delete ${e.target.dataset.name}?`)) {
            await deleteDoc(doc(db, "users", e.target.dataset.id));
            await loadMembers();
            await loadFundBalance();
          }
        }
      });

      elements.cancelEdit.addEventListener("click", () => {
        elements.editModal.classList.add("hidden");
        elements.editForm.reset();
      });

      elements.editForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        try {
          const id = elements.editMemberId.value;
          await updateDoc(doc(db, "users", id), {
            name: elements.editName.value,
            email: elements.editEmail.value,
            status: elements.editStatus.value,
            shares: parseInt(elements.editShares.value),
            balance: parseFloat(elements.editBalance.value),
            approvalDate: new Date(elements.editApprovalDate.value),
          });
          elements.editModal.classList.add("hidden");
          elements.editForm.reset();
          await loadMembers();
          await loadFundBalance();
        } catch (error) {
          showError("Failed to update member: " + error.message);
        }
      });

      // Approve/Reject Transactions
      elements.requestsList.addEventListener("click", async (e) => {
        const id = e.target.dataset.id;
        if (!id) return;

        try {
          const transactionDoc = await getDoc(doc(db, "transactions", id));
          const data = transactionDoc.data();
          const userDoc = await getDoc(doc(db, "users", data.memberId));
          const user = userDoc.data();
          const batch = writeBatch(db);

          if (e.target.classList.contains("approve-btn")) {
            if (data.type === "deposit") {
              batch.update(doc(db, "users", data.memberId), {
                balance: (user.balance || 0) + data.amount,
                shares: (user.shares || 0) + data.amount / 10, // 1 share = ‚Ç±10
              });
            } else if (data.type === "cashout" && (user.balance || 0) >= data.amount) {
              batch.update(doc(db, "users", data.memberId), {
                balance: Math.max(0, (user.balance || 0) - data.amount),
                shares: Math.max(0, (user.shares || 0) - data.amount / 10),
              });
            } else {
              throw new Error("Insufficient balance for cashout.");
            }
            batch.update(doc(db, "transactions", id), { status: "approved" });
          } else if (e.target.classList.contains("reject-btn")) {
            batch.update(doc(db, "transactions", id), { status: "rejected" });
          }

          await batch.commit();
          await loadMembers();
          await loadFundBalance();
        } catch (error) {
          showError("Failed to process transaction: " + error.message);
        }
      });

      // Filter and Sort Transactions
      elements.historyFilter.addEventListener("change", displayTransactionHistory);
      elements.historySort.addEventListener("change", displayTransactionHistory);

      // Server Time Button
      elements.serverTimeBtn.addEventListener("click", async () => {
        const serverTime = await getServerTime();
        alert(`Server Time: ${serverTime.toLocaleString("en-PH")}`);
      });

      // Adjust Balance Button
      elements.adjustBalanceBtn.addEventListener("click", async () => {
        await adjustBalances();
        await loadMembers();
        await loadFundBalance();
      });

      // Logout
      elements.logoutBtn.addEventListener("click", () => {
        signOut(auth).then(() => (window.location.href = "/login"));
      });

      // Initialize
      onAuthStateChanged(auth, (user) => {
        if (!user) window.location.href = "/login";
        else {
          initializeChart();
          loadMembers();
          loadFundBalance();
          loadRequests();
          loadTransactionHistory();
          loadDailyReport();
        }
      });
    </script>
  </body>
</html>
